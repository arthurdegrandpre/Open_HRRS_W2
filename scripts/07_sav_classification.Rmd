---
title: "07_classification"
author: "Arthur de Grandpr√©"
date: "05 feb 2021"
output: 
  html_document: 
    toc: yes
    toc_float: yes
---


# Intro

This is the seventh (last) script of the Open HRRS W2 workflow for open source high resolution remote sensing of vegetation cover optically complex waters.

This script is used to perform iterative random forest classifications to classify aquatic vegetation classes from other features, resulting in a vegetation cover map. The performance of this step is highly dependent on the quality of the training sets, the segmentation, and the array of features used as predictors in the random forest.  

Since actual ground validation is rare, expert visual validation is used both for training and model validation. While this is not an optimal solution, existing validation data could be used at any step to enhance results. Satisfactory classification performance is attained when the expert estimates the error does not compromise the classification objectives.  

Quantitative estimates of the accuracy can be obtained through multiple methods :  
1. Separation of the training set in multiples parts : one for predicting, and the other for validation (usually 70 % / 30 % respectively).  
2. Using the out-of-bag confusion matrix from the random forest.  
3. Applying random resampling of the training set to estimate it's robustness.
  
This step requires manual work in the form of constructed training sets (multipolygon files, as shp or gpkg) built from QGIS or ArcGIS.  

It treats one image at a time, in order to allow for selection of the right training sets, and the tweaking of some parameters.

Multiple images of the same region and satellite acquisition should be able to be classified based on the same classifier training.


# 1. Setting up the R environment

## 1.1. Libraries

First, load the required libraries. They can be installed using the *install.packages("package.name", dependencies = TRUE)* function. The velox package requires the devtools library and a special function to download it from Github instead of CRAN.

```{r setup}
rm(list=ls()) ; gc()
otb.path  = "C:\\OTB-7.2.0-Win64\\bin"
otb.ramlimit = 16000

 # GSIF support has been dropped by CRAN, but is still available in their archives. Use the following function to install it (version 0.5.5.1).

# install.packages("https://cran.r-project.org/src/contrib/Archive/GSIF/GSIF_0.5-5.1.tar.gz", repos=NULL, type="source")

library(GSIF)
library(stringr)
library(raster)
library(tidyverse)
library(caret)
library(spatialEco)
library(randomForest)
library(landscapemetrics)
library(rgdal)
library(caret)
library(doParallel)
library(rgeos)
library(rgdal)
library(snowfall)
library(sf)
library(foreach)
```

## 1.2. Inputs / Outputs

note : I usually start by transferring my "ready" images in a folder that will be used as input. Preventing some messy image selection.

```{r, eval=T}
input_rasters = normalizePath(dir("../data/work/ready_mosaics/",
         pattern = ".tif$",
         full.names = T,
         recursive = F))

i = 1 # raster of interest position


input_t_obj = dir("../data/training_sets/veg/", full.names=T, pattern = ".gpkg$")


output_dir = normalizePath("../data/work/ready_mosaics/results/")
segmentation_dir = normalizePath(paste0(output_dir,"/segmentation/"))
features_dir = normalizePath(paste0(output_dir,"/features/"))
tiles_tif_output = paste0(output_dir,"/tiles/")
tiles_tif_f_output = paste0(output_dir,"/tiles_f/")
tiles_shp_output = paste0(tiles_tif_output,"/segmentation/")
tiles_classif_output = paste0(tiles_tif_output,"/classification/")
classified_output = paste0(output_dir,"/classified/")

rf_model_output = "../data/rf_models/"
```

```{r}
for(k in c(output_dir,
           segmentation_dir,
           features_dir,
           tiles_tif_output,
           tiles_shp_output,
           tiles_tif_f_output,
           tiles_classif_output,
           rf_model_output,
           classified_output)){
  if(file.exists(k)){}else{
    dir.create(k)}
}
```


## 1.3. Define functions
```{r define feature extract function, eval=T}

feature.HaralickTextureExtraction <- function(
                           raster.in = "",
                           out.path  = "",
                           name      = "",
                           channel = "1",   #default 1, selected channel index in input image
                           texture   = "simple",  #default simple, also available "advanced" or "higher"
                           parameters.min = "0", #input image minimum value
                           parameters.max = "1", #input image maximum value
                           parameters.xrad = "2", #xradius in pixels
                           parameters.yrad = "2", #yradisu in pixels
                           parameters.xoff = "1", #xoffset in pixels
                           parameters.yoff = "1", #yoffset in pixels
                           parameters.nbbin = "8" # bins per axis of histogram
                           
                           ){
  
# Set configuration      
conf <- paste("-RAM ",otb.ramlimit,
              "-in",raster.in,
              "-channel",channel,
              "-texture",texture,
              "-parameters.min",parameters.min,
              "-parameters.max",parameters.max,
              "-parameters.xrad",parameters.xrad,
              "-parameters.yrad",parameters.yrad,
              "-parameters.xoff",parameters.xoff,
              "-parameters.yoff",parameters.yoff,
              "-parameters.nbbin",parameters.nbbin,
              "-out",paste0(out.path,"/",name)
              )
  
  shell(paste("pushd ",otb.path,"&& otbcli_HaralickTextureExtraction ",conf))

write.table(x = conf,file = paste(out.path,"/",name,"_conf.txt",sep=""),row.names = F, col.names = F)
}
```

```{r define segmentation function, eval=T}
meanshift.segm <- function(raster.in = "",
                           out.path  = "",
                           name      = "",
                           filter.meanshift.spatialr = "5",   #default 5
                           filter.meanshift.ranger   = "0.003",  #default 15
                           filter.meanshift.thres    = "0.001", #default 0.1
                           filter.meanshift.maxiter  = "100", #default 100
                           filter.meanshift.minsize  = "10"  #default 100
                           
                           ){
  
# Set configuration      
conf <- paste("-in",raster.in,"-filter meanshift","-filter.meanshift.spatialr",filter.meanshift.spatialr,
                "-filter.meanshift.ranger",filter.meanshift.ranger,"-filter.meanshift.thres",filter.meanshift.thres,
                "-filter.meanshift.maxiter",filter.meanshift.maxiter,"-filter.meanshift.minsize",filter.meanshift.minsize,
                "-mode vector","-mode.vector.out",paste0(out.path,"/",name,".shp"))
  
  shell(paste("pushd ",otb.path,"&& otbcli_Segmentation ",conf))

write.table(x = conf,file = paste(out.path,"/",name,"_conf.txt",sep=""),row.names = F, col.names = F)
}
```

```{r zonalstats function, eval=T}
minx = function(x, na.rm=T){min(x,na.rm=T)}
maxx = function(x, na.rm=T){max(x, na.rm=T)}
meanx = function(x, na.rm=T){if(length(x)==1){return(x)}else{sum(x, na.rm=T)/length(x)}}
sdx = function(x, na.rm=T){if(length(x)==1){return(0)}else{sd(x,na.rm=T)}}
```

```{r tiling_function, eval=T}
make_tiles <- function(j, tile.tbl, 
                          out.path.tif = out.path.tif,
                          source = input_rasters){
  
  out.tif = paste0(out.path.tif, paste0("/T_",j), tile.tbl[j,"ID"], ".tif")
  
  if(!file.exists(out.tif)){
    m <- readGDAL(source[i], offset=unlist(tile.tbl[j,c("offset.y","offset.x")]),
                 region.dim=unlist(tile.tbl[j,c("region.dim.y","region.dim.x")]),
                 output.dim=unlist(tile.tbl[j,c("region.dim.y","region.dim.x")]),
                 silent = TRUE)
    
    if(!all(is.na(m@data[,1]))){
      writeGDAL(m, out.tif, type="Float32", 
                options="COMPRESS=DEFLATE")
  }
  }
}

```

```{r, eval=T}
zonal.stats.small = function (x, y, stats = c("min", "mean", "max")) 
{
    if (class(y) != "RasterLayer" & class(y) != "RasterStack" & 
        class(y) != "RasterBrick") 
        stop("y must be a raster (layer, stack, brick) class object")
    if (class(x) != "SpatialPolygonsDataFrame") 
        stop("x must be a SpatialPolygonsDataFrame object")
    rvx <- velox::velox(y)
    ldf <- rvx$extract(sp = x, small=T)
    names(ldf) <- row.names(x)
    stats.fun <- function(x, m = stats) {
        slist <- list()
        for (i in 1:length(m)) {
            slist[[i]] <- apply(x, MARGIN = 2, m[i], na.rm = TRUE)
        }
        return(as.data.frame(t(unlist(slist))))
    }
    results <- lapply(ldf, FUN = stats.fun)
    results <- do.call("rbind", results)
    rn <- vector()
    for (n in stats) {
        rn <- append(rn, paste(n, names(y), sep = "."))
    }
    names(results) <- rn
    return(results)
}
```

```{r}
classify_tiles = function(j,
                          in.path.r = tiles_tif_f_output,
                          in.path.shp = tiles_shp_output,
                          out.path.shp.class = tiles_classif_output){
# 
#   tifs = dir(tiles_tif_f_output, pattern=".tif$", full.names=T)
#   shps = dir(tiles_shp_output, pattern=".shp$", full.names=T)
#   in.path.r = tifs
#   in.path.shp = shps
#   out.path.shp.class = tiles_classif_output
# j=255
# 
# sort(in.path.r)
# sort(in.path.shp)
out.shp = out.path.shp.class
# out.shp = paste0(paste0(out.path.shp.class,sub(".tif.*","",sub(".*tifs/","",in.path.r))[j],".shp"))  

r = raster::brick(in.path.r[j])

if(nlayers(r)==25){
  names(r)=c("B","G","R","N","NH1","NH2","NH3","NH4","NH5","NH6","NH7","NH8","BH1","BH2","BH3","BH4","BH5","BH6","BH7","BH8","NDVI","SAVI","EVI","NDAVI","WAVI")
} else {
  names(r)=c("C","B","G","Y","R","RE","N1","N","NH1","NH2","NH3","NH4","NH5","NH6","NH7","NH8","BH1","BH2","BH3","BH4","BH5","BH6","BH7","BH8","NDVI","SAVI","EVI","NDAVI","WAVI")
}

# r = approxNA(r)

pc = rgdal::readOGR(in.path.shp[j])
pc = rgeos::gBuffer(pc, byid=T, width=0)
pc = raster::crop(pc,r)
pc = pc[order(pc$DN),]

# plot(r[[1]])
# plot(pc, add=T)
# pct = pc[1:10000,]
# pct

zonal_s = zonal.stats.small(x = pc, y = r, stats = c("minx","maxx","meanx","sdx"))
parea = as.data.frame(gArea(pc,byid=T))
colnames(parea)=c("area")

pperi = polyPerimeter(pc)

pc2=pc

pc2@data = cbind(pc@data,zonal_s)
pc2@data = cbind(pc2@data,parea)
pc2@data = cbind(pc2@data,pperi)

pc2@data = pc2@data[is.finite(rowSums(pc2@data[,2:ncol(pc2@data)])),]
pc2@data$class = "unknown"
pc2@data$class = predict(rfp, pc2@data, type="raw")
pc3 = pc
pc3@data = merge(pc@data,pc2@data,all=T)

rgdal::writeOGR(pc3,
                dsn=paste0(out.shp,"TC_",j),
                driver="ESRI Shapefile",
                layer=paste0("TC_",j),
                overwrite_layer = T)
}

```

# 2. Segmentation and feature extraction

## 2.1. Segmentation

```{r}

imgs = input_rasters

meanshift.segm(filter.meanshift.spatialr = "5",      # default 5
               filter.meanshift.ranger   = "0.001",  # default 15 # 0.0025 good for LSP, not LSF, <0.0015 for LSF
               filter.meanshift.thres    = "0.0005",  # default 0.1
               filter.meanshift.maxiter  = "100",    # default 100
               filter.meanshift.minsize  = "5",     # default 100
               raster.in = gsub("/","\\\\",imgs[i]),
               out.path  = gsub("/","\\\\",segmentation_dir),
               name      = gsub("(.*)mosaics\\\\","",imgs[i]))

  # }

```

## 2.2. Feature extraction

Let's extract haralick texture information from NIR and Blue bands, as well as calculate aquatic vegetation indexes

### 2.2.1. NIR haralick
```{r}

if(file.exists((paste0(features_dir,"/haralick")))){}else(dir.create((paste0(features_dir,"/haralick"))))

r = brick(imgs[i])

  if(nlayers(r)==8){
feature.HaralickTextureExtraction(
                           raster.in = gsub("/","\\\\",imgs[i]),
                           out.path  = paste0(gsub("/","\\\\",features_dir),"\\haralick"),
                           name      = paste0("n_ht_",str_split(gsub(".*\\\\","",imgs[i]),"\\.")[[1]][1]),
                           channel = "8",   #default 1, selected channel index in input image
                           texture   = "simple",  #default simple, also available "advanced" or "higher"
                           parameters.min = "0", #input image minimum value
                           parameters.max = "0.3", #input image maximum value
                           parameters.xrad = "5", #xradius in pixels
                           parameters.yrad = "5", #yradius in pixels
                           parameters.xoff = "10", #xoffset in pixels
                           parameters.yoff = "10", #yoffset in pixels
                           parameters.nbbin = "64" # bins per axis of histogram
                           )
  } else {
feature.HaralickTextureExtraction(
                           raster.in = gsub("/","\\\\",imgs[i]),
                           out.path  = paste0(gsub("/","\\\\",features_dir),"\\haralick"),
                           name      = paste0("n_ht_",str_split(gsub(".*\\\\","",imgs[i]),"\\.")[[1]][1]),
                           channel = "4",   #default 1, selected channel index in input image
                           texture   = "simple",  #default simple, also available "advanced" or "higher"
                           parameters.min = "0", #input image minimum value
                           parameters.max = "0.3", #input image maximum value
                           parameters.xrad = "5", #xradius in pixels
                           parameters.yrad = "5", #yradisu in pixels
                           parameters.xoff = "10", #xoffset in pixels
                           parameters.yoff = "10", #yoffset in pixels
                           parameters.nbbin = "64" # bins per axis of histogram
                           )

  }
  
```

### 2.2.2. Blue haralick

```{r}

if(file.exists((paste0(features_dir,"/haralick")))){}else(dir.create((paste0(features_dir,"/haralick"))))

  if(nlayers(r)==8){
feature.HaralickTextureExtraction(
                           raster.in = gsub("/","\\\\",imgs[i]),
                           out.path  = paste0(gsub("/","\\\\",features_dir),"\\haralick"),
                           name      = paste0("b_ht_",str_split(gsub(".*\\\\","",imgs[i]),"\\.")[[1]][1]),
                           channel = "2",   #default 1, selected channel index in input image
                           texture   = "simple",  #default simple, also available "advanced" or "higher"
                           parameters.min = "0", #input image minimum value
                           parameters.max = "0.3", #input image maximum value
                           parameters.xrad = "5", #xradius in pixels
                           parameters.yrad = "5", #yradisu in pixels
                           parameters.xoff = "10", #xoffset in pixels
                           parameters.yoff = "10", #yoffset in pixels
                           parameters.nbbin = "64" # bins per axis of histogram
                           )
  } else {
feature.HaralickTextureExtraction(
                           raster.in = gsub("/","\\\\",imgs[i]),
                           out.path  = paste0(gsub("/","\\\\",features_dir),"\\haralick"),
                           name      = paste0("b_ht_",str_split(gsub(".*\\\\","",imgs[i]),"\\.")[[1]][1]),
                           channel = "1",   #default 1, selected channel index in input image
                           texture   = "simple",  #default simple, also available "advanced" or "higher"
                           parameters.min = "0", #input image minimum value
                           parameters.max = "0.3", #input image maximum value
                           parameters.xrad = "5", #xradius in pixels
                           parameters.yrad = "5", #yradisu in pixels
                           parameters.xoff = "10", #xoffset in pixels
                           parameters.yoff = "10", #yoffset in pixels
                           parameters.nbbin = "64" # bins per axis of histogram
                           )

  }
```

### 2.2.3. Vegetation indexes and stack building

```{r, eval=F}

  features = c("\\haralick") # "localstats" and "edge" removed
r = brick(imgs[i])
# dir(paste0(features_dir,features))
# features
for(j in seq_along(features)){
  r = addLayer(r, brick(dir(paste0(features_dir,features[j]),full.names=TRUE, pattern="n_??_(.*).tif$")[i]))
  r = addLayer(r, brick(dir(paste0(features_dir,features[j]),full.names=TRUE, pattern="b_??_(.*).tif$")[i]))
  }
  
  L = 0.5
  
  if(nlayers(r)==20){
  r$ndvi =  (r[[4]]-r[[3]]) / (r[[4]]+r[[3]])
  r$savi =  (1+L)*((r[[4]]-r[[3]]) / (r[[4]]+r[[3]]+L))
  r$evi  =  2.5*(((r[[4]]-r[[3]]) / (r[[4]]+6*r[[3]]-7.5*r[[1]]+1)))
  r$ndavi=  (r[[4]]-r[[1]]) / (r[[4]]+r[[1]])
  r$wavi =  (1+L)*((r[[4]]-r[[1]]) / (r[[4]]+r[[1]]+L))
  names(r) = c("B","G","R","N","NH1","NH2","NH3","NH4","NH5","NH6","NH7","NH8","BH1","BH2","BH3","BH4","BH5","BH6","BH7","BH8","NDVI","SAVI","EVI","NDAVI","WAVI")
  }else{
  r$ndvi =  (r[[8]]-r[[4]]) / (r[[8]]+r[[4]])
  r$savi =  (1+L)*((r[[8]]-r[[4]]) / (r[[8]]+r[[4]]+L))
  r$evi  =  2.5*(((r[[8]]-r[[4]]) / (r[[8]]+6*r[[4]]-7.5*r[[2]]+1)))
  r$ndavi=  (r[[8]]-r[[2]]) / (r[[8]]+r[[2]])
  r$wavi =  (1+L)*((r[[8]]-r[[2]]) / (r[[8]]+r[[2]]+L))
  names(r) = c("C","B","G","Y","R","RE","N1","N","NH1","NH2","NH3","NH4","NH5","NH6","NH7","NH8","BH1","BH2","BH3","BH4","BH5","BH6","BH7","BH8","NDVI","SAVI","EVI","NDAVI","WAVI")
  }
  
  writeRaster(r, paste0(features_dir,"\\",str_split(gsub(".*\\\\","",imgs[i]),"\\.")[[1]][1],".tif"), overwrite=T)


```

# 3. training and exploration

The training set is built within QGIS, although the actual data extraction is done in R.
This is the first step of the iterative part of the classification and requires some minor adjustments for file names and positions.

```{r eval=F, message=FALSE, warning=FALSE}

rasters = dir(features_dir, pattern=".tif$", full.names=T)
training_objects = input_t_obj

p = 4 # position of the training set in the list of training_objects

r = brick(rasters[i])

if(nlayers(r)==25){
  names(r)=c("B","G","R","N","NH1","NH2","NH3","NH4","NH5","NH6","NH7","NH8","BH1","BH2","BH3","BH4","BH5","BH6","BH7","BH8","NDVI","SAVI","EVI","NDAVI","WAVI")
} else {
  names(r)=c("C","B","G","Y","R","RE","N1","N","NH1","NH2","NH3","NH4","NH5","NH6","NH7","NH8","BH1","BH2","BH3","BH4","BH5","BH6","BH7","BH8","NDVI","SAVI","EVI","NDAVI","WAVI")
}

s = st_read(training_objects[p]) %>% 
    filter(class %in% c("v_sub_high",
                      "v_sub_low",
                      "w_shallow",
                      "w_deep",
                      "v_floating",
                      "o_boatwave")) %>% 
  as_Spatial()

s = s[,2:dim(s@data)[2]]
s = spTransform(s, crs(r))

zonal_s = zonal.stats.small(x = s, y = r, stats = c("minx","maxx","meanx","sdx"))
s@data = cbind(s@data,zonal_s)

parea = as.data.frame(rgeos::gArea(s, byid=T))
colnames(parea)=c("area")
s@data = cbind(s@data,parea)

pperi = polyPerimeter(s)
s@data = cbind(s@data,pperi)

s2 = s@data[is.finite(rowSums(s@data[,2:ncol(s@data)])),]

s3 = s2 %>%
  select_if(function(x) !(all(is.na(x)) | all(x=="")))

s3 = droplevels(s3)
```

```{r, eval=F}
table(s3$class)
colnames(s3)

ggplot(s3, aes(x = reorder(class,meanx.B), y = meanx.B))+
  geom_boxplot()+
  theme(axis.text.x = element_text(angle = 45))
ggplot(s3, aes(x = reorder(class,meanx.G), y = meanx.G))+
  geom_boxplot()+
  theme(axis.text.x = element_text(angle = 45))
ggplot(s3, aes(x = reorder(class,meanx.R), y = meanx.R))+
  geom_boxplot()+
  theme(axis.text.x = element_text(angle = 45))
ggplot(s3, aes(x = reorder(class,meanx.N), y = meanx.N))+
  geom_boxplot()+
  theme(axis.text.x = element_text(angle = 45))
ggplot(s3, aes(x = reorder(class,meanx.NDVI), y = meanx.NDVI))+
  geom_boxplot()+
  theme(axis.text.x = element_text(angle = 45))

```

```{r, eval=F}
# THIS CHUNK WAS USED TO REGROUP CLASSES, NOT REQUIRED 

# table(s3$class)
# st3 = s3 %>% 
#   mutate(hclass = fct_collapse(class,
#                                others = c("o_boat","w_waves"),
#                                water = c("w_bg","w_brown","w_shallow"),
#                                waterp = c("w_p_dark","w_dark"),
#                                veg_em = c("v_p_em","v_em"),
#                                veg_sub = c("v_sub_high","v_sub_low"))) %>% 
#   select(hclass, everything())
# 
# table(st3$hclass)
```

```{r, eval=F}
# THIS CHUNK LOOKS AT THE NEW CLASSES, NOT REQUIRED

# table(st3$hclass)
# 
# ggplot(st3, aes(x = reorder(hclass,meanx.B), y = meanx.B))+
#   geom_boxplot()+
#   theme(axis.text.x = element_text(angle = 45))
# ggplot(st3, aes(x = reorder(hclass,meanx.G), y = meanx.G))+
#   geom_boxplot()+
#   theme(axis.text.x = element_text(angle = 45))
# ggplot(st3, aes(x = reorder(hclass,meanx.R), y = meanx.R))+
#   geom_boxplot()+
#   theme(axis.text.x = element_text(angle = 45))
# ggplot(st3, aes(x = reorder(hclass,meanx.N), y = meanx.N))+
#   geom_boxplot()+
#   theme(axis.text.x = element_text(angle = 45))
# ggplot(st3, aes(x = reorder(hclass,meanx.NDVI), y = meanx.NDVI))+
#   geom_boxplot()+
#   theme(axis.text.x = element_text(angle = 45))
```


```{r, eval=F}
# THIS CHUNK LIMITS THE NUMBER OF OBJECTS PER CLASS, CAN BE USED FOR BALANCING, NOT REQUIRED

# sampsize.limit=1000
# sampsize.v = c()
# for(i in 1:length(table(st3$hclass))){
#    if(table(st3$hclass)[[i]]<sampsize.limit){
#     sampsize.v=append(sampsize.v,table(st3$hclass)[[i]])
#   } else {sampsize.v=append(sampsize.v,sampsize.limit)}
# }
# 
# s4 = st3 %>% 
#   arrange(hclass) %>% 
#   group_by(hclass) %>% 
#   nest() %>% 
#   ungroup() %>% 
#   mutate(n = sampsize.v)
# 
# s5 = s4 %>% 
#   mutate(samp = purrr::map2(data, n, dplyr::sample_n))
# 
# s6 = s5 %>% 
#   select(-data) %>% 
#   unnest(samp) %>% 
#   select(-2)
# 
# s7 = s6 %>% 
#   select(-2)

```

```{r parRF, eval=F}

cl <- makePSOCKcluster(detectCores()-2)
registerDoParallel(cl)

rfp <- train(class ~ ., data = s3, method = "parRF")

stopCluster(cl)

rm(s);rm(s2);rm(zonal_s)

confusionMatrix(rfp)
varImp(rfp)
rfp
plot(rfp)
saveRDS(rfp, "../data/rf_models/2019_rf_veg_04.Rdata") # Change the number to fit the attempt
```

# 4. Classification

## 4.1. tiling and segmentation

Those steps only need to pe performed once, except if the segmentation or feature extraction appear limiting to the quality of the classification. 

### For spectral images

```{r}

### tiling
obj = GDALinfo(input_rasters[i])
tile.lst = getSpatialTiles(obj, block.x=500, return.SpatialPolygons=TRUE)
tile.tbl = getSpatialTiles(obj, block.x=500, return.SpatialPolygons=FALSE)

sfInit(parallel=TRUE, cpus=parallel::detectCores())
sfExport("make_tiles","tile.tbl","i","tiles_tif_output","input_rasters","tile.lst")
sfLibrary(rgdal)
sfLibrary(plyr)
sfLibrary(rgeos)
sfLibrary(gdalUtils)

out.lst = sfClusterApplyLB(1:nrow(tile.tbl),
                           function(x){make_tiles(x, tile.tbl ,tiles_tif_output, source = input_rasters)})

sfStop()


### segmentation

t_imgs = dir(tiles_tif_output,full.names=T, pattern=".tif$")

 for(i in seq_along(t_imgs)){
   meanshift.segm(filter.meanshift.spatialr = "5",   #default 5 ## TESTING TO 3 to 10
                  filter.meanshift.ranger   = "0.001",  #default 15 TEST 0.002  2019 : test 0.0015 test (underseg) 0.0005 (overseg), 0.0001 (overseg)                   
                  filter.meanshift.thres    = "0.0005", #default 0.1  test 0.0005 to 0.00025
                  filter.meanshift.maxiter  = "100", #default 100 
                  filter.meanshift.minsize  = "5",  #default 100 
               raster.in = gsub("/","\\\\",t_imgs[i]),
               out.path  = gsub("/","\\\\",tiles_shp_output),
               name      = gsub(".tif.*","",gsub(".*tiles/","",t_imgs[i])))

 }

```

### For feature images
```{r}
feature_rasters = dir(features_dir, pattern=".tif$",full.names=T)
### tiling

obj = GDALinfo(feature_rasters[i])
tile.lst = getSpatialTiles(obj, block.x=500, return.SpatialPolygons=TRUE)
tile.tbl = getSpatialTiles(obj, block.x=500, return.SpatialPolygons=FALSE)

sfInit(parallel=TRUE, cpus=parallel::detectCores())
sfExport("make_tiles","tile.tbl","i","tiles_tif_f_output","feature_rasters","tile.lst")
sfLibrary(rgdal)
sfLibrary(plyr)
sfLibrary(rgeos)
sfLibrary(gdalUtils)

out.lst = sfClusterApplyLB(1:nrow(tile.tbl),
                           function(x){make_tiles(x, tile.tbl ,tiles_tif_f_output, source = feature_rasters)})

sfStop()

```

## 4.2. classification

IMPORTANT : DO NOT RUN WITHIN RMARKDOWN WITHOUT REMOVING MESSAGE AND WARNING, (OR COPY TO CONSOLE)
```{r, message=F, warning=F}
 ### IMPORTANT : DO NOT RUN WITH message and warning = T, the console prints fill up the system.
rfp = readRDS("../data/rf_models/2019_rf_veg_04.Rdata") # MAKE SURE TO CALL THE RIGHT RANDOM FOREST MODEL
tiles = dir(tiles_tif_f_output, pattern=".tif$", full.names=T)
shps = dir(tiles_shp_output, pattern=".shp$", full.names=T)

sfInit(parallel=TRUE, cpus=parallel::detectCores()-0)
sfExport("tiles_tif_output","tiles_shp_output","tiles_classif_output","classify_tiles","rfp","minx","maxx","meanx","sdx","zonal.stats.small","tiles","shps")
sfLibrary(rgdal)
sfLibrary(raster)
sfLibrary(randomForest)
sfLibrary(spatialEco)
sfLibrary(rgeos)
sfLibrary(sp)
sfLibrary(stringr)

out.lst = sfClusterApplyLB(1:length(dir(tiles_tif_output,"tif$")),
                           function(x){classify_tiles(x,
                                                      tiles,
                                                      shps,
                                                      tiles_classif_output)})

sfStop()
```

```{r}

cs = dir(tiles_classif_output, pattern=".shp$",full.names=T, recursive=T)
  
  mosaic_shps = function(u,cs){
    s = st_read(cs[u])
    diss = s %>%
      group_by(class) %>% 
      summarise() %>% 
      st_buffer(0)
  }

  cl=parallel::makeCluster(detectCores()-1)
  registerDoParallel(cl)

  m = foreach(u=1:length(cs),
              .combine=rbind,
              .packages=c("sf","tidyverse")) %dopar% {
                mosaic_shps(u, cs)}

  stopCluster(cl)
  plot(m)
  
  st_write(m,
         paste0(classified_output,"2019_v04.gpkg"), # DON'T FORGET TO ADJUST THE NAME OF THE FINAL OUTPUT
         driver="GPKG",
         delete_dsn=T)
```

# END





------------------------------------------------------------------






# OLD

```{r, eval=F}
fr = dir("D:/arthur/digitalglobe_archives/ready_mosaics/",
         pattern = ".tif$",
         full.names = T,
         recursive = F)# full rasters

ndvi_output_dir = "D:/arthur/digitalglobe_archives/ready_mosaics/ndvi/"

# for(i in seq_along(fr)){
#   r = brick(fr[i])
#   if(nlayers(r)==8){
#     r$NDVI = (r[[8]]-r[[4]])/(r[[8]]+r[[4]])
#   } else {
#     r$NDVI = (r[[4]]-r[[3]])/(r[[4]]+r[[3]])
#   }
#   writeRaster(r, paste0(ndvi_output_dir,str_sub(fr[i],-35)), overwrite=T)
#   }

fr2 = dir(ndvi_output_dir,
          pattern=".tif$",
          full.names=T,
          recursive=F)

output_dir = "D:/arthur/digitalglobe_archives/ready_mosaics/features2/"
```


```{r feature extractions NIR, eval=F}

otb.path  = "C:\\OTB-7.0.0-Win64\\bin"
otb.ramlimit = 4096 # does not seem to work without changing windows environment variable (not an issue)

for(i in seq_along(fr2)){

  r = brick(fr2[i])
  
  if(nlayers(r)==8){
feature.LocalStatisticExtraction(
                           raster.in = gsub("/","\\\\",fr2[i]),
                           out.path  = paste0(gsub("/","\\\\",output_dir),"localstats"),
                           name      = paste0("lsn_",str_sub(fr2[i],-35)),
                           channel   = "8",   # default 1, selected channel index in input image
                           radius    = "5"    # default 3, computational window radius
                           )
  
feature.EdgeExtraction(
                           raster.in = gsub("/","\\\\",fr2[i]),
                           out.path  = paste0(gsub("/","\\\\",output_dir),"edge"),
                           name      = paste0("een_",str_sub(fr2[i],-35)),
                           channel   = "8",        # default 1, selected channel index in input image
                           filter    = "gradient"  # default 3, computational window radius
                           )

feature.HaralickTextureExtraction(
                           raster.in = gsub("/","\\\\",fr2[i]),
                           out.path  = paste0(gsub("/","\\\\",output_dir),"haralick"),
                           name      = paste0("htn_",str_sub(fr2[i],-35)),
                           channel   = "8",   # default 1, selected channel index in input image
                           texture   = "simple",   # default simple, also available "advanced" or "higher"
                           parameters.min   = "0", # input image minimum value
                           parameters.max   = "1", # input image maximum value
                           parameters.xrad  = "3", # xradius in pixels
                           parameters.yrad  = "3", # yradius in pixels
                           parameters.xoff  = "1", # xoffset in pixels
                           parameters.yoff  = "1", # yoffset in pixels
                           parameters.nbbin = "100"  # bins per axis of histogram
                           )
  } else {
feature.LocalStatisticExtraction(
                           raster.in = gsub("/","\\\\",fr2[i]),
                           out.path  = paste0(gsub("/","\\\\",output_dir),"localstats"),
                           name      = paste0("lsn_",str_sub(fr2[i],-35)),
                           channel   = "4",   # default 1, selected channel index in input image
                           radius    = "5"    # default 3, computational window radius
                           )
  
feature.EdgeExtraction(
                           raster.in = gsub("/","\\\\",fr2[i]),
                           out.path  = paste0(gsub("/","\\\\",output_dir),"edge"),
                           name      = paste0("een_",str_sub(fr2[i],-35)),
                           channel   = "4",        # default 1, selected channel index in input image
                           filter    = "gradient"  # default 3, computational window radius
                           )

feature.HaralickTextureExtraction(
                           raster.in = gsub("/","\\\\",fr2[i]),
                           out.path  = paste0(gsub("/","\\\\",output_dir),"haralick"),
                           name      = paste0("htn_",str_sub(fr2[i],-35)),
                           channel   = "4",   #default 1, selected channel index in input image
                           texture   = "simple",   # default simple, also available "advanced" or "higher"
                           parameters.min   = "0", # input image minimum value
                           parameters.max   = "1", # input image maximum value
                           parameters.xrad  = "2", # xradius in pixels
                           parameters.yrad  = "2", # yradisu in pixels
                           parameters.xoff  = "1", # xoffset in pixels
                           parameters.yoff  = "1", # yoffset in pixels
                           parameters.nbbin = "100"  # bins per axis of histogram
                           )
  }
  }
```


```{r feature extractions blue, eval=F}
for(i in seq_along(fr2)){

  r = brick(fr2[i])
  
  if(nlayers(r)==8){
feature.LocalStatisticExtraction(
                           raster.in = gsub("/","\\\\",fr2[i]),
                           out.path  = paste0(gsub("/","\\\\",output_dir),"localstats"),
                           name      = paste0("lsb_",str_sub(fr2[i],-35)),
                           channel   = "2",   # default 1, selected channel index in input image
                           radius    = "5"    # default 3, computational window radius
                           )
  
feature.EdgeExtraction(
                           raster.in = gsub("/","\\\\",fr2[i]),
                           out.path  = paste0(gsub("/","\\\\",output_dir),"edge"),
                           name      = paste0("eeb_",str_sub(fr2[i],-35)),
                           channel   = "2",        # default 1, selected channel index in input image
                           filter    = "gradient"  # default 3, computational window radius
                           )

feature.HaralickTextureExtraction(
                           raster.in = gsub("/","\\\\",fr2[i]),
                           out.path  = paste0(gsub("/","\\\\",output_dir),"haralick"),
                           name      = paste0("htb_",str_sub(fr2[i],-35)),
                           channel   = "2",   # default 1, selected channel index in input image
                           texture   = "simple",   # default simple, also available "advanced" or "higher"
                           parameters.min   = "0", # input image minimum value
                           parameters.max   = "1", # input image maximum value
                           parameters.xrad  = "3", # xradius in pixels
                           parameters.yrad  = "3", # yradius in pixels
                           parameters.xoff  = "1", # xoffset in pixels
                           parameters.yoff  = "1", # yoffset in pixels
                           parameters.nbbin = "100"  # bins per axis of histogram
                           )
  } else {
feature.LocalStatisticExtraction(
                           raster.in = gsub("/","\\\\",fr2[i]),
                           out.path  = paste0(gsub("/","\\\\",output_dir),"localstats"),
                           name      = paste0("lsb_",str_sub(fr2[i],-35)),
                           channel   = "1",   # default 1, selected channel index in input image
                           radius    = "5"    # default 3, computational window radius
                           )
  
feature.EdgeExtraction(
                           raster.in = gsub("/","\\\\",fr2[i]),
                           out.path  = paste0(gsub("/","\\\\",output_dir),"edge"),
                           name      = paste0("eeb_",str_sub(fr2[i],-35)),
                           channel   = "1",        # default 1, selected channel index in input image
                           filter    = "gradient"  # default 3, computational window radius
                           )

feature.HaralickTextureExtraction(
                           raster.in = gsub("/","\\\\",fr2[i]),
                           out.path  = paste0(gsub("/","\\\\",output_dir),"haralick"),
                           name      = paste0("htb_",str_sub(fr2[i],-35)),
                           channel   = "1",   #default 1, selected channel index in input image
                           texture   = "simple",   # default simple, also available "advanced" or "higher"
                           parameters.min   = "0", # input image minimum value
                           parameters.max   = "1", # input image maximum value
                           parameters.xrad  = "2", # xradius in pixels
                           parameters.yrad  = "2", # yradisu in pixels
                           parameters.xoff  = "1", # xoffset in pixels
                           parameters.yoff  = "1", # yoffset in pixels
                           parameters.nbbin = "100"  # bins per axis of histogram
                           )
  }
  }
  
```

```{r feature extractions ndvi, eval=F}
for(i in seq_along(fr2)){

  r = brick(fr2[i])
  
  if(nlayers(r)==9){
feature.LocalStatisticExtraction(
                           raster.in = gsub("/","\\\\",fr2[i]),
                           out.path  = paste0(gsub("/","\\\\",output_dir),"localstats"),
                           name      = paste0("lsnir_",str_sub(fr2[i],-35)),
                           channel   = "9",   # default 1, selected channel index in input image
                           radius    = "5"    # default 3, computational window radius
                           )
  
feature.EdgeExtraction(
                           raster.in = gsub("/","\\\\",fr2[i]),
                           out.path  = paste0(gsub("/","\\\\",output_dir),"edge"),
                           name      = paste0("eenir_",str_sub(fr2[i],-35)),
                           channel   = "9",        # default 1, selected channel index in input image
                           filter    = "gradient"  # default 3, computational window radius
                           )

feature.HaralickTextureExtraction(
                           raster.in = gsub("/","\\\\",fr2[i]),
                           out.path  = paste0(gsub("/","\\\\",output_dir),"haralick"),
                           name      = paste0("htnir_",str_sub(fr2[i],-35)),
                           channel   = "9",   # default 1, selected channel index in input image
                           texture   = "simple",   # default simple, also available "advanced" or "higher"
                           parameters.min   = "0", # input image minimum value
                           parameters.max   = "1", # input image maximum value
                           parameters.xrad  = "3", # xradius in pixels
                           parameters.yrad  = "3", # yradius in pixels
                           parameters.xoff  = "1", # xoffset in pixels
                           parameters.yoff  = "1", # yoffset in pixels
                           parameters.nbbin = "100"  # bins per axis of histogram
                           )
  } else {

     feature.LocalStatisticExtraction(
                           raster.in = gsub("/","\\\\",fr2[i]),
                           out.path  = paste0(gsub("/","\\\\",output_dir),"localstats"),
                           name      = paste0("lsnir_",str_sub(fr2[i],-35)),
                           channel   = "5",   # default 1, selected channel index in input image
                           radius    = "5"    # default 3, computational window radius
                           )
  
feature.EdgeExtraction(
                           raster.in = gsub("/","\\\\",fr2[i]),
                           out.path  = paste0(gsub("/","\\\\",output_dir),"edge"),
                           name      = paste0("eenir_",str_sub(fr2[i],-35)),
                           channel   = "5",        # default 1, selected channel index in input image
                           filter    = "gradient"  # default 3, computational window radius
                           )

feature.HaralickTextureExtraction(
                           raster.in = gsub("/","\\\\",fr2[i]),
                           out.path  = paste0(gsub("/","\\\\",output_dir),"haralick"),
                           name      = paste0("htnir_",str_sub(fr2[i],-35)),
                           channel   = "5",   #default 1, selected channel index in input image
                           texture   = "simple",   # default simple, also available "advanced" or "higher"
                           parameters.min   = "0", # input image minimum value
                           parameters.max   = "1", # input image maximum value
                           parameters.xrad  = "2", # xradius in pixels
                           parameters.yrad  = "2", # yradisu in pixels
                           parameters.xoff  = "1", # xoffset in pixels
                           parameters.yoff  = "1", # yoffset in pixels
                           parameters.nbbin = "100"  # bins per axis of histogram
                           )
  }
  }
  
```
NOTE : ADDED NDVI, CHANGED NBBIN FROM 8 TO 100
```{r, eval=F, message=F, warning=F}
for(i in seq_along(fr2)){
 
 r = brick(fr2[i])
  
  features = c("localstats","edge","haralick")
  
  for(j in seq_along(features)){
  r = addLayer(r, brick(dir(paste0(output_dir,features[j]),full.names=TRUE, pattern=".tif$")[i]))
  r = addLayer(r, brick(dir(paste0(output_dir,features[j]),full.names=TRUE, pattern=".tif$")[i+length(fr2)]))
  r = addLayer(r, brick(dir(paste0(output_dir,features[j]),full.names=TRUE, pattern=".tif$")[i+2*length(fr2)]))
  }
  
  writeRaster(r, paste0(output_dir,str_sub(fr2[i],-35)), overwrite=T)
}

```

# 2. segmentation

```{r segmentation, eval=F}
input_dir = "D:/arthur/digitalglobe_archives/ready_mosaics/features2/"
output_dir = "D:/Arthur/digitalglobe_archives/ready_mosaics/shapefiles2/"
imgs = dir(input_dir,full.names=T, pattern=".tif$")

 # for(i in seq_along(imgs)){
   i=1
meanshift.segm(filter.meanshift.spatialr = "5",      # default 5
               filter.meanshift.ranger   = "0.005",  # default 15
               filter.meanshift.thres    = "0.0005",  # default 0.1
               filter.meanshift.maxiter  = "200",    # default 100
               filter.meanshift.minsize  = "3",     # default 100
               raster.in = gsub("/","\\\\",imgs[i]),
               out.path  = gsub("/","\\\\",output_dir),
               name      = str_sub(imgs[i],-35))

  # }
```

# 3. training set building and exploration

The training set is built within QGIS, although the actual data extraction is done in R.

```{r, eval=F}
input_rasters = "D:/arthur/digitalglobe_archives/ready_mosaics/features2/" #input BOA images with additionnal features
input_t_obj = "../data/training_sets/veg/" #location of training sets.
```


```{r eval=F, message=FALSE, warning=FALSE}

rasters = dir(input_rasters, pattern=".tif$", full.names=T)
training_objects = dir(input_t_obj, pattern=".gpkg$", full.names=T)

i = 1
r = brick(rasters[i])

if(nlayers(r)==5+4+4+4+3+8+8+8){
  names(r)=c("B","G","R","N","NDVI","NLS1","NLS2","NLS3","NLS4","NEE","NHA1","NHA2","NHA3","NHA4","NHA5","NHA6","NHA7","NHA8","BLS1","BLS2","BLS3","BLS4","BEE","BHA1","BHA2","BHA3","BHA4","BHA5","BHA6","BHA7","BHA8","NDVILS1","NDVILS2","NDVILS3","NDVILS4","NDVIEE","NDVIHA1","NDVIHA2","NDVIHA3","NDVIHA4","NDVIHA5","NDVIHA6","NDVIHA7","NDVIHA8")
} else {
  names(r)=c("C","B","G","Y","R","RE","N1","N","NDVI","NLS1","NLS2","NLS3","NLS4","NEE","NHA1","NHA2","NHA3","NHA4","NHA5","NHA6","NHA7","NHA8","BLS1","BLS2","BLS3","BLS4","BEE","BHA1","BHA2","BHA3","BHA4","BHA5","BHA6","BHA7","BHA8","NDVILS1","NDVILS2","NDVILS3","NDVILS4","NDVIEE","NDVIHA1","NDVIHA2","NDVIHA3","NDVIHA4","NDVIHA5","NDVIHA6","NDVIHA7","NDVIHA8")
}

s = readOGR(training_objects[9])
s = s[,2:dim(s@data)[2]]
s = spTransform(s, crs(r))

zonal_s = zonal.stats(x = s, y = r, stats = c("minx","maxx","meanx","sdx"))
s@data = cbind(s@data,zonal_s)

parea = as.data.frame(rgeos::gArea(s, byid=T))
colnames(parea)=c("area")
s@data = cbind(s@data,parea)

pperi = polyPerimeter(s)
s@data = cbind(s@data,pperi)

s2 = s@data[is.finite(rowSums(s@data[,2:ncol(s@data)])),]

s3 = s2 %>%
  select_if(function(x) !(all(is.na(x)) | all(x=="")))

s3 = droplevels(s3)
```

```{r, eval=F}
table(s3$class)
colnames(s3)

ggplot(s3, aes(x = reorder(class,meanx.B), y = meanx.B))+
  geom_boxplot()+
  theme(axis.text.x = element_text(angle = 45))
ggplot(s3, aes(x = reorder(class,meanx.G), y = meanx.G))+
  geom_boxplot()+
  theme(axis.text.x = element_text(angle = 45))
ggplot(s3, aes(x = reorder(class,meanx.R), y = meanx.R))+
  geom_boxplot()+
  theme(axis.text.x = element_text(angle = 45))
ggplot(s3, aes(x = reorder(class,meanx.N), y = meanx.N))+
  geom_boxplot()+
  theme(axis.text.x = element_text(angle = 45))
ggplot(s3, aes(x = reorder(class,meanx.NDVI), y = meanx.NDVI))+
  geom_boxplot()+
  theme(axis.text.x = element_text(angle = 45))

```

```{r, eval=F}
table(s3$class)
st3 = s3 %>% 
  mutate(hclass = fct_collapse(class, tveg = c("scrops","sgrass","strees","swetlands"),
                               tanthro = c("aboats","ahouses","aroads"),
                               tothers = c("ssand","sshadow","ssoil"),
                               waterl = c("wbg","wwaves","wwhite"),
                               waterd = c("wbrown","wdark"),
                               wveg = c("semac","ssmac"))) %>% 
  select(hclass, everything())
```

```{r, eval=F}
table(st3$hclass)

ggplot(st3, aes(x = reorder(hclass,meanx.B), y = meanx.B))+
  geom_boxplot()+
  theme(axis.text.x = element_text(angle = 45))
ggplot(st3, aes(x = reorder(hclass,meanx.G), y = meanx.G))+
  geom_boxplot()+
  theme(axis.text.x = element_text(angle = 45))
ggplot(st3, aes(x = reorder(hclass,meanx.R), y = meanx.R))+
  geom_boxplot()+
  theme(axis.text.x = element_text(angle = 45))
ggplot(st3, aes(x = reorder(hclass,meanx.N), y = meanx.N))+
  geom_boxplot()+
  theme(axis.text.x = element_text(angle = 45))
ggplot(st3, aes(x = reorder(hclass,meanx.NDVI), y = meanx.NDVI))+
  geom_boxplot()+
  theme(axis.text.x = element_text(angle = 45))
```


```{r, eval=F}
sampsize.limit=1000
sampsize.v = c()
for(i in 1:length(table(st3$hclass))){
   if(table(st3$hclass)[[i]]<sampsize.limit){
    sampsize.v=append(sampsize.v,table(st3$hclass)[[i]])
  } else {sampsize.v=append(sampsize.v,sampsize.limit)}
}

s4 = st3 %>% 
  arrange(hclass) %>% 
  group_by(hclass) %>% 
  nest() %>% 
  ungroup() %>% 
  mutate(n = sampsize.v)

s5 = s4 %>% 
  mutate(samp = purrr::map2(data, n, dplyr::sample_n))

s6 = s5 %>% 
  select(-data) %>% 
  unnest(samp) %>% 
  select(-2)

s7 = s6 %>% 
  select(-2)
```

```{r parRF, eval=F}

cl <- makePSOCKcluster(detectCores()-2)
registerDoParallel(cl)

rfp <- train(hclass ~ ., data = s7, method = "parRF")


?train
stopCluster(cl)

rm(s);rm(s2);rm(zonal_s)

confusionMatrix(rfp)
varImp(rfp)
rfp
plot(rfp)
```

```{r singleRF, eval=F}
#### singlecore randomforest ####

rf = randomForest(formula = class~.,
                  data = s3,
                  proximity = T,
                  ntree = 10000,
                  # mtry = 20,
                  # nodesize = 10,
                  importance = T,
                  sampsize=sampsize.v,
                  replace=T)

plot(rf)
varImpPlot(rf)
importance = as.data.frame(importance(rf))
head(importance, 10)
rf
```





# 4. hierarchical / nested random forest

### level 1 
```{r}

### definitions 

input_rasters = dir("D:/arthur/digitalglobe_archives/ready_mosaics/ndvi/",
                    pattern=".tif$",
                    full.names=T,
                    recursive=F)
output_dir = "D:/arthur/digitalglobe_archives/ready_mosaics/tiles2/"
output_name = "classified_2009v01a.gpkg"
i=1

tile_size = 500

tiling.test = FALSE
feature.test = FALSE
segmentation.test = FALSE
classify.test = FALSE

### directories setup

if(dir.exists(output_dir)==F){
  dir.create(output_dir)
}
if(dir.exists(paste0(output_dir,"tifs/"))==F){
  dir.create(paste0(output_dir,"tifs/"))
}

if(dir.exists(paste0(output_dir,"tifs/feature_extract/"))){
  unlink(paste0(output_dir,"tifs/feature_extract/"),recursive=T, force=T)
  } else{
    dir.create(paste0(output_dir,"tifs/feature_extract/"))
  }
dir.create(paste0(output_dir,"tifs/feature_extract/edge"))
dir.create(paste0(output_dir,"tifs/feature_extract/localstats"))
dir.create(paste0(output_dir,"tifs/feature_extract/haralick"))

out.path.tif = paste0(output_dir,"tifs/")

if(dir.exists(paste0(output_dir,"tifs/feature_extract/shps/"))==F){
  dir.create(paste0(output_dir,"tifs/feature_extract/shps/"))
}

if(dir.exists(paste0(output_dir,"classified/"))==F){
  dir.create(paste0(output_dir,"classified/"))
}


### tiling
if(tiling.test == TRUE){
  obj = GDALinfo(input_rasters[i])
  tile.lst = getSpatialTiles(obj,
                           block.x = tile_size,
                           return.SpatialPolygons = TRUE)
  tile.tbl = getSpatialTiles(obj,
                           block.x = tile_size,
                           return.SpatialPolygons = FALSE)
  
  sfInit(parallel=TRUE, cpus=parallel::detectCores())
  sfExport("make_tiles","tile.tbl","i","out.path.tif","input_rasters","tile.lst")
  sfLibrary(rgdal)
  sfLibrary(plyr)
  sfLibrary(rgeos)
  sfLibrary(gdalUtils)

  out.lst = sfClusterApplyLB(1:nrow(tile.tbl),
                           function(x){make_tiles(x,
                                                  tile.tbl,
                                                  out.path.tif,
                                                  source = input_rasters)})

  sfStop()
}

### feature extraction
if(feature.test == TRUE) {

  tiles = dir(paste0(output_dir,"tifs/"),
              pattern=".tif$",
              full.names=T)

feat_output_dir = paste0(output_dir,"tifs/feature_extract/")
  
    
otb.path  = "C:\\OTB-7.0.0-Win64\\bin"
otb.ramlimit = 4096 # does not seem to work without changing windows environment variable (not an issue)

# NIR
for(i in seq_along(tiles)){

  r = brick(tiles[i])
  
  if(nlayers(r)==9){
feature.LocalStatisticExtraction(
                           raster.in = gsub("/","\\\\",tiles[i]),
                           out.path  = paste0(gsub("/","\\\\",feat_output_dir),"localstats"),
                           name      = paste0("lsn_",sub(".*tifs/", "", tiles[i])),
                           channel   = "8",   # default 1, selected channel index in input image
                           radius    = "5"    # default 3, computational window radius
                           )
  
feature.EdgeExtraction(
                           raster.in = gsub("/","\\\\",tiles[i]),
                           out.path  = paste0(gsub("/","\\\\",feat_output_dir),"edge"),
                           name      = paste0("een_",sub(".*tifs/", "", tiles[i])),
                           channel   = "8",        # default 1, selected channel index in input image
                           filter    = "gradient"  # default 3, computational window radius
                           )

feature.HaralickTextureExtraction(
                           raster.in = gsub("/","\\\\",tiles[i]),
                           out.path  = paste0(gsub("/","\\\\",feat_output_dir),"haralick"),
                           name      = paste0("htn_",sub(".*tifs/", "", tiles[i])),
                           channel   = "8",   # default 1, selected channel index in input image
                           texture   = "simple",   # default simple, also available "advanced" or "higher"
                           parameters.min   = "0", # input image minimum value
                           parameters.max   = "1", # input image maximum value
                           parameters.xrad  = "3", # xradius in pixels
                           parameters.yrad  = "3", # yradius in pixels
                           parameters.xoff  = "1", # xoffset in pixels
                           parameters.yoff  = "1", # yoffset in pixels
                           parameters.nbbin = "100"  # bins per axis of histogram
                           )
  } else {
feature.LocalStatisticExtraction(
                           raster.in = gsub("/","\\\\",tiles[i]),
                           out.path  = paste0(gsub("/","\\\\",feat_output_dir),"localstats"),
                           name      = paste0("lsn_",sub(".*tifs/", "", tiles[i])),
                           channel   = "4",   # default 1, selected channel index in input image
                           radius    = "5"    # default 3, computational window radius
                           )
  
feature.EdgeExtraction(
                           raster.in = gsub("/","\\\\",tiles[i]),
                           out.path  = paste0(gsub("/","\\\\",feat_output_dir),"edge"),
                           name      = paste0("een_",sub(".*tifs/", "", tiles[i])),
                           channel   = "4",        # default 1, selected channel index in input image
                           filter    = "gradient"  # default 3, computational window radius
                           )

feature.HaralickTextureExtraction(
                           raster.in = gsub("/","\\\\",tiles[i]),
                           out.path  = paste0(gsub("/","\\\\",feat_output_dir),"haralick"),
                           name      = paste0("htn_",sub(".*tifs/", "", tiles[i])),
                           channel   = "4",   #default 1, selected channel index in input image
                           texture   = "simple",   # default simple, also available "advanced" or "higher"
                           parameters.min   = "0", # input image minimum value
                           parameters.max   = "1", # input image maximum value
                           parameters.xrad  = "2", # xradius in pixels
                           parameters.yrad  = "2", # yradisu in pixels
                           parameters.xoff  = "1", # xoffset in pixels
                           parameters.yoff  = "1", # yoffset in pixels
                           parameters.nbbin = "100"  # bins per axis of histogram
                           )
  }
}

# BLUE

for(i in seq_along(tiles)){

  r = brick(tiles[i])
  
  if(nlayers(r)==9){
feature.LocalStatisticExtraction(
                           raster.in = gsub("/","\\\\",tiles[i]),
                           out.path  = paste0(gsub("/","\\\\",feat_output_dir),"localstats"),
                           name      = paste0("lsb_",sub(".*tifs/", "", tiles[i])),
                           channel   = "2",   # default 1, selected channel index in input image
                           radius    = "5"    # default 3, computational window radius
                           )
  
feature.EdgeExtraction(
                           raster.in = gsub("/","\\\\",tiles[i]),
                           out.path  = paste0(gsub("/","\\\\",feat_output_dir),"edge"),
                           name      = paste0("eeb_",sub(".*tifs/", "", tiles[i])),
                           channel   = "2",        # default 1, selected channel index in input image
                           filter    = "gradient"  # default 3, computational window radius
                           )

feature.HaralickTextureExtraction(
                           raster.in = gsub("/","\\\\",tiles[i]),
                           out.path  = paste0(gsub("/","\\\\",feat_output_dir),"haralick"),
                           name      = paste0("htb_",sub(".*tifs/", "", tiles[i])),
                           channel   = "2",   # default 1, selected channel index in input image
                           texture   = "simple",   # default simple, also available "advanced" or "higher"
                           parameters.min   = "0", # input image minimum value
                           parameters.max   = "1", # input image maximum value
                           parameters.xrad  = "3", # xradius in pixels
                           parameters.yrad  = "3", # yradius in pixels
                           parameters.xoff  = "1", # xoffset in pixels
                           parameters.yoff  = "1", # yoffset in pixels
                           parameters.nbbin = "100"  # bins per axis of histogram
                           )
  } else {
feature.LocalStatisticExtraction(
                           raster.in = gsub("/","\\\\",tiles[i]),
                           out.path  = paste0(gsub("/","\\\\",feat_output_dir),"localstats"),
                           name      = paste0("lsb_",sub(".*tifs/", "", tiles[i])),
                           channel   = "1",   # default 1, selected channel index in input image
                           radius    = "5"    # default 3, computational window radius
                           )
  
feature.EdgeExtraction(
                           raster.in = gsub("/","\\\\",tiles[i]),
                           out.path  = paste0(gsub("/","\\\\",feat_output_dir),"edge"),
                           name      = paste0("eeb_",sub(".*tifs/", "", tiles[i])),
                           channel   = "1",        # default 1, selected channel index in input image
                           filter    = "gradient"  # default 3, computational window radius
                           )

feature.HaralickTextureExtraction(
                           raster.in = gsub("/","\\\\",tiles[i]),
                           out.path  = paste0(gsub("/","\\\\",feat_output_dir),"haralick"),
                           name      = paste0("htb_",sub(".*tifs/", "", tiles[i])),
                           channel   = "1",   #default 1, selected channel index in input image
                           texture   = "simple",   # default simple, also available "advanced" or "higher"
                           parameters.min   = "0", # input image minimum value
                           parameters.max   = "1", # input image maximum value
                           parameters.xrad  = "2", # xradius in pixels
                           parameters.yrad  = "2", # yradisu in pixels
                           parameters.xoff  = "1", # xoffset in pixels
                           parameters.yoff  = "1", # yoffset in pixels
                           parameters.nbbin = "100"  # bins per axis of histogram
                           )
  }
  }


## NDVI

for(i in seq_along(tiles)){

  r = brick(tiles[i])
  
  if(nlayers(r)==9){
feature.LocalStatisticExtraction(
                           raster.in = gsub("/","\\\\",tiles[i]),
                           out.path  = paste0(gsub("/","\\\\",feat_output_dir),"localstats"),
                           name      = paste0("lsnir_",sub(".*tifs/", "", tiles[i])),
                           channel   = "9",   # default 1, selected channel index in input image
                           radius    = "5"    # default 3, computational window radius
                           )
  
feature.EdgeExtraction(
                           raster.in = gsub("/","\\\\",tiles[i]),
                           out.path  = paste0(gsub("/","\\\\",feat_output_dir),"edge"),
                           name      = paste0("eenir_",sub(".*tifs/", "", tiles[i])),
                           channel   = "9",        # default 1, selected channel index in input image
                           filter    = "gradient"  # default 3, computational window radius
                           )

feature.HaralickTextureExtraction(
                           raster.in = gsub("/","\\\\",tiles[i]),
                           out.path  = paste0(gsub("/","\\\\",feat_output_dir),"haralick"),
                           name      = paste0("htnir_",sub(".*tifs/", "", tiles[i])),
                           channel   = "9",   # default 1, selected channel index in input image
                           texture   = "simple",   # default simple, also available "advanced" or "higher"
                           parameters.min   = "0", # input image minimum value
                           parameters.max   = "1", # input image maximum value
                           parameters.xrad  = "3", # xradius in pixels
                           parameters.yrad  = "3", # yradius in pixels
                           parameters.xoff  = "1", # xoffset in pixels
                           parameters.yoff  = "1", # yoffset in pixels
                           parameters.nbbin = "100"  # bins per axis of histogram
                           )
  } else {

     feature.LocalStatisticExtraction(
                           raster.in = gsub("/","\\\\",tiles[i]),
                           out.path  = paste0(gsub("/","\\\\",feat_output_dir),"localstats"),
                           name      = paste0("lsnir_",sub(".*tifs/", "", tiles[i])),
                           channel   = "5",   # default 1, selected channel index in input image
                           radius    = "5"    # default 3, computational window radius
                           )
  
feature.EdgeExtraction(
                           raster.in = gsub("/","\\\\",tiles[i]),
                           out.path  = paste0(gsub("/","\\\\",feat_output_dir),"edge"),
                           name      = paste0("eenir_",sub(".*tifs/", "", tiles[i])),
                           channel   = "5",        # default 1, selected channel index in input image
                           filter    = "gradient"  # default 3, computational window radius
                           )

feature.HaralickTextureExtraction(
                           raster.in = gsub("/","\\\\",tiles[i]),
                           out.path  = paste0(gsub("/","\\\\",feat_output_dir),"haralick"),
                           name      = paste0("htnir_",sub(".*tifs/", "", tiles[i])),
                           channel   = "5",   #default 1, selected channel index in input image
                           texture   = "simple",   # default simple, also available "advanced" or "higher"
                           parameters.min   = "0", # input image minimum value
                           parameters.max   = "1", # input image maximum value
                           parameters.xrad  = "2", # xradius in pixels
                           parameters.yrad  = "2", # yradisu in pixels
                           parameters.xoff  = "1", # xoffset in pixels
                           parameters.yoff  = "1", # yoffset in pixels
                           parameters.nbbin = "100"  # bins per axis of histogram
                           )
  }
}

for(i in seq_along(tiles)){
 
 r = brick(tiles[i])
  
  features = c("localstats","edge","haralick")
  
  for(j in seq_along(features)){
  r = addLayer(r,
               brick(dir(paste0(feat_output_dir,features[j]),
                         full.names=TRUE,
                         pattern=".tif$")[i]))
  r = addLayer(r,
               brick(dir(paste0(feat_output_dir,features[j]),
                         full.names=TRUE,
                         pattern=".tif$")[i+length(tiles)]))
  r = addLayer(r,
               brick(dir(paste0(feat_output_dir,features[j]),
                         full.names=TRUE,
                         pattern=".tif$")[i+2*length(tiles)]))
  }
  
  writeRaster(r, paste0(feat_output_dir,sub(".*tifs/", "", tiles[i])), overwrite=T)
}
}

### segmentation
if(segmentation.test == TRUE){
  input_dir = paste0(output_dir,"tifs/feature_extract/")
  output_seg_dir = paste0(output_dir,"tifs/feature_extract/shps/")
  
  imgs = dir(input_dir,full.names=T, pattern=".tif$")

 for(i in seq_along(imgs)){
   meanshift.segm(filter.meanshift.spatialr = "5",      # default 5
               filter.meanshift.ranger   = "0.005",  # default 15
               filter.meanshift.thres    = "0.0005",  # default 0.1
               filter.meanshift.maxiter  = "200",    # default 100
               filter.meanshift.minsize  = "3",     # default 100
               raster.in = gsub("/","\\\\",imgs[i]),
               out.path  = gsub("/","\\\\",output_seg_dir),
               name      = sub(".tif.*","",sub(".*feature_extract/","",imgs[i])))
 }
}

### classification
if(classify.test == TRUE) {
  tifs = dir(paste0(output_dir,"tifs/feature_extract/"),
             full.names=T,
             pattern=".tif$")
  shps = dir(paste0(output_dir,"tifs/feature_extract/shps/"),
             full.names=T,
             pattern=".shp$")
  output_shps = paste0(output_dir,"classified/")
  
  sfInit(parallel=TRUE, cpus=parallel::detectCores()-1)
  sfExport("tifs","shps","output_shps","classify_tiles","rfp","minx","maxx","meanx","sdx","zonal.stats.small")
  sfLibrary(rgdal)
  sfLibrary(raster)
  sfLibrary(randomForest)
  sfLibrary(spatialEco)
  sfLibrary(rgeos)
  sfLibrary(sp)
  
  out.lst = sfClusterApplyLB(1:length(tifs),
                           function(x){classify_tiles(x, tifs, shps, output_shps)})
  sfStop()

  cs = dir(output_shps, pattern=".shp$",full.names=T)
  
  mosaic_shps = function(u,cs){
    s = st_read(cs[u])
    diss = s %>%
      group_by(class) %>% 
      summarise() %>% 
      st_buffer(0)
  }

  cl=parallel::makeCluster(detectCores()-1)
  registerDoParallel(cl)

  m = foreach(u=1:length(cs),
              .combine=rbind,
              .packages=c("sf","tidyverse")) %dopar% {
                mosaic_shps(u, cs)}

  stopCluster(cl)
  plot(m)
  
  st_write(m,
         paste0(output_dir,"classified/",output_name),
         driver="GPKG",
         delete_dsn=T)
}
```


## level 2

clipping
```{r}
input_rasters = dir("D:/arthur/digitalglobe_archives/ready_mosaics/features2/",
                    full.names=T,
                    pattern=".tif$")
path_wm_raster = "D:/arthur/digitalglobe_archives/ready_mosaics/lv2/"

if(dir.exists(path_wm_raster)==F){
  dir.create(path_wm_raster)
}

mw = m %>%
  filter(str_detect(class,"^w"))

i=1

r = brick(input_rasters[i])
r2 = mask(r, mw)

writeRaster(r2, paste0(path_wm_raster,str_sub(input_rasters[i],-35)), overwrite=T)
```

training lv2

version 2 : subsample training set prior to extract
```{r}
path_wm_raster = "D:/arthur/digitalglobe_archives/ready_mosaics/features2"
input_rasters = dir(path_wm_raster, full.names=T, pattern=".tif")

lv1_poly_dir = dir("D:/Arthur/digitalglobe_archives/ready_mosaics/classified",
                   pattern=".gpkg$",
                   full.names=T)

lv1_poly = st_read(lv1_poly_dir[2]) %>% 
  filter(str_detect(class,"^w"))

i=1
r = brick(input_rasters[i])

input_t_obj = "../data/training_sets/veg/" #location of training sets.
training_objects = dir(input_t_obj, pattern=".gpkg$", full.names=T)


sampsize.limit=4000


if(nlayers(r)==5+4+4+4+3+8+8+8){
  names(r)=c("B","G","R","N","NDVI","NLS1","NLS2","NLS3","NLS4","NEE","NHA1","NHA2","NHA3","NHA4","NHA5","NHA6","NHA7","NHA8","BLS1","BLS2","BLS3","BLS4","BEE","BHA1","BHA2","BHA3","BHA4","BHA5","BHA6","BHA7","BHA8","NDVILS1","NDVILS2","NDVILS3","NDVILS4","NDVIEE","NDVIHA1","NDVIHA2","NDVIHA3","NDVIHA4","NDVIHA5","NDVIHA6","NDVIHA7","NDVIHA8")
} else {
  names(r)=c("C","B","G","Y","R","RE","N1","N","NDVI","NLS1","NLS2","NLS3","NLS4","NEE","NHA1","NHA2","NHA3","NHA4","NHA5","NHA6","NHA7","NHA8","BLS1","BLS2","BLS3","BLS4","BEE","BHA1","BHA2","BHA3","BHA4","BHA5","BHA6","BHA7","BHA8","NDVILS1","NDVILS2","NDVILS3","NDVILS4","NDVIEE","NDVIHA1","NDVIHA2","NDVIHA3","NDVIHA4","NDVIHA5","NDVIHA6","NDVIHA7","NDVIHA8")
}

s = st_read(training_objects[5])
s = s[,-1]
s = st_transform(s, crs(r))
s0 = st_intersection(s, lv1_poly)
s01 = s0 %>% 
  filter(st_geometry_type(.) %in% c("POLYGON"))


ss = s01 %>% 
  mutate(h2class = fct_collapse(class,
                                tt = c("scrops","sgrass","strees",
                                       "swetlands","aboats","ahouses",
                                       "aroads","ssand","sshadow","ssoil"),
                                waterl = c("wbg","wwhite"),
                                waterd = c("wbrown","wdark"),
                                wother = c("wwaves"),
                                vem = c("semac"),
                                vsub = c("ssmac"))) %>% 
  select(h2class, everything())

ss$h2class=factor(ss$h2class)

sampsize.v = c()
for(i in 1:length(table(ss$h2class))){
   if(table(ss$h2class)[[i]]<sampsize.limit){
    sampsize.v=append(sampsize.v,table(ss$h2class)[[i]])
  } else {sampsize.v=append(sampsize.v,sampsize.limit)}
}

s1 = ss %>% 
  arrange(h2class) %>% 
  group_by(h2class) %>% 
  nest() %>% 
  ungroup() %>% 
  mutate(n = sampsize.v)

s2 = s1 %>% 
  mutate(samp = purrr::map2(data, n, dplyr::sample_n))

s3 = s2 %>% 
  select(-data) %>% 
  unnest(samp) %>% 
  select(-2) %>% 
  st_as_sf()

s4 = s3 %>% 
  select(-2)

table(s4$h2class)

s5 = as_Spatial(s4, cast=T)
    
zonal_s = zonal.stats.small(x = s5, y = r, stats = c("minx","maxx","meanx","sdx"))

s6 = bind_cols(s4,zonal_s)

s7 = as_Spatial(s6, cast=T)

parea = as.data.frame(rgeos::gArea(s7, byid=T))
colnames(parea)=c("area")
s7@data = cbind(s7@data,parea)

pperi = polyPerimeter(s7)
s7@data = cbind(s7@data,pperi)

s7@data = s7@data[,-2]

s8 = s7@data[is.finite(rowSums(s7@data[,2:ncol(s7@data)])),]
s9 = s8 %>%
  select_if(function(x) !(all(is.na(x)) | all(x=="")))



###

cl <- makePSOCKcluster(detectCores()-2)
registerDoParallel(cl)

rfp2 <- train(h2class ~ ., data = s9, method = "parRF")

stopCluster(cl)

rm(s);rm(s2);rm(zonal_s)

confusionMatrix(rfp2, rfp2$pred)
confusionMatrix(rfp2)
varImp(rfp2)
summary(rfp2)
plot(rfp2)
rfp=rfp2
```


version 1 : subsamble training set after extract (too slow)
```{r, eval=F, include=F}
path_wm_raster = "D:/arthur/digitalglobe_archives/ready_mosaics/lv2/"
input_rasters = dir(path_wm_raster, full.names=T, pattern=".tif")
i=1
r = brick(input_rasters[i])

input_t_obj = "../data/training_sets/veg/" #location of training sets.
training_objects = dir(input_t_obj, pattern=".gpkg$", full.names=T)

if(nlayers(r)==5+4+4+4+3+8+8+8){
  names(r)=c("B","G","R","N","NDVI","NLS1","NLS2","NLS3","NLS4","NEE","NHA1","NHA2","NHA3","NHA4","NHA5","NHA6","NHA7","NHA8","BLS1","BLS2","BLS3","BLS4","BEE","BHA1","BHA2","BHA3","BHA4","BHA5","BHA6","BHA7","BHA8","NDVILS1","NDVILS2","NDVILS3","NDVILS4","NDVIEE","NDVIHA1","NDVIHA2","NDVIHA3","NDVIHA4","NDVIHA5","NDVIHA6","NDVIHA7","NDVIHA8")
} else {
  names(r)=c("C","B","G","Y","R","RE","N1","N","NDVI","NLS1","NLS2","NLS3","NLS4","NEE","NHA1","NHA2","NHA3","NHA4","NHA5","NHA6","NHA7","NHA8","BLS1","BLS2","BLS3","BLS4","BEE","BHA1","BHA2","BHA3","BHA4","BHA5","BHA6","BHA7","BHA8","NDVILS1","NDVILS2","NDVILS3","NDVILS4","NDVIEE","NDVIHA1","NDVIHA2","NDVIHA3","NDVIHA4","NDVIHA5","NDVIHA6","NDVIHA7","NDVIHA8")
}

s = readOGR(training_objects[2])
s = s[,2:dim(s@data)[2]]
s = spTransform(s, crs(r))

zonal_s = zonal.stats(x = s, y = r, stats = c("minx","maxx","meanx","sdx"))

s@data = cbind(s@data,zonal_s)

parea = as.data.frame(rgeos::gArea(s, byid=T))
colnames(parea)=c("area")
s@data = cbind(s@data,parea)

pperi = polyPerimeter(s)
s@data = cbind(s@data,pperi)

s2 = s@data[is.finite(rowSums(s@data[,2:ncol(s@data)])),]

s3 = s2 %>%
  select_if(function(x) !(all(is.na(x)) | all(x=="")))

s3 = droplevels(s3)

st3 = s3 %>% 
  mutate(h2class = fct_collapse(class,
                                tt = c("scrops","sgrass","strees",
                                       "swetlands","aboats","ahouses",
                                       "aroads","ssand","sshadow","ssoil"),
                                waterl = c("wbg","wwhite"),
                                waterd = c("wbrown","wdark"),
                                wother = c("wwaves"),
                                vem = c("semac"),
                                vsub = c("ssmac"))) %>% 
  select(h2class, everything())

sampsize.limit=1000
sampsize.v = c()
for(i in 1:length(table(st3$h2class))){
   if(table(st3$h2class)[[i]]<sampsize.limit){
    sampsize.v=append(sampsize.v,table(st3$h2class)[[i]])
  } else {sampsize.v=append(sampsize.v,sampsize.limit)}
}

s4 = st3 %>% 
  arrange(h2class) %>% 
  group_by(h2class) %>% 
  nest() %>% 
  ungroup() %>% 
  mutate(n = sampsize.v)

s5 = s4 %>% 
  mutate(samp = purrr::map2(data, n, dplyr::sample_n))

s6 = s5 %>% 
  select(-data) %>% 
  unnest(samp) %>% 
  select(-2)

s7 = s6 %>% 
  select(-2)

cl <- makePSOCKcluster(detectCores()-2)
registerDoParallel(cl)

# s7_noEE <- select(s7, -contains("EE"))

rfp2 <- train(h2class ~ ., data = s7, method = "parRF")

stopCluster(cl)

rm(s);rm(s2);rm(zonal_s)

confusionMatrix(rfp2)
varImp(rfp2)
rfp2
plot(rfp2)
rfp=rfp2
```


```{r}

### definitions 

input_rasters = dir(path_wm_raster,
                    pattern=".tif$",
                    full.names=T,
                    recursive=F)

output_dir = "D:/arthur/digitalglobe_archives/ready_mosaics/tiles2_b/"
output_name = "classified_2009v01b7_4k.gpkg"
i=1

tile_size = 300

tiling.test = FALSE
segmentation.test = FALSE
classify.test = TRUE

### directories setup

if(dir.exists(output_dir)==F){
  dir.create(output_dir)
}
if(dir.exists(paste0(output_dir,"tifs/"))==F){
  dir.create(paste0(output_dir,"tifs/"))
}

if(dir.exists(paste0(output_dir,"shps/"))==F){
  dir.create(paste0(output_dir,"shps/"))
}

if(dir.exists(paste0(output_dir,"classified/"))==F){
  dir.create(paste0(output_dir,"classified/"))
}

### tiling
if(tiling.test == TRUE){
  obj = GDALinfo(input_rasters[i])
  tile.lst = getSpatialTiles(obj,
                           block.x = tile_size,
                           return.SpatialPolygons = TRUE)
  tile.tbl = getSpatialTiles(obj,
                           block.x = tile_size,
                           return.SpatialPolygons = FALSE)
  out.path.tif = paste0(output_dir,"tifs/")
    
  sfInit(parallel=TRUE, cpus=parallel::detectCores())
  sfExport("make_tiles","tile.tbl","i","out.path.tif","input_rasters","tile.lst")
  sfLibrary(rgdal)
  sfLibrary(plyr)
  sfLibrary(rgeos)
  sfLibrary(gdalUtils)

  out.lst = sfClusterApplyLB(1:nrow(tile.tbl),
                           function(x){make_tiles(x,
                                                  tile.tbl,
                                                  out.path.tif,
                                                  source = input_rasters)})

  sfStop()
}

### segmentation
otb.path  = "C:\\OTB-7.0.0-Win64\\bin"
if(segmentation.test == TRUE){
  input_dir = paste0(output_dir,"tifs/")
  output_seg_dir = paste0(output_dir,"shps/")
  
  imgs = dir(input_dir,full.names=T, pattern=".tif$")

 for(i in seq_along(imgs)){
   meanshift.segm(filter.meanshift.spatialr = "5",      # default 5
               filter.meanshift.ranger   = "3",  # default 15 # previous 0.005
               filter.meanshift.thres    = "0.0005",  # default 0.1 # previous 0.0005
               filter.meanshift.maxiter  = "200",    # default 100
               filter.meanshift.minsize  = "4",     # default 100
               raster.in = gsub("/","\\\\",imgs[i]),
               out.path  = gsub("/","\\\\",output_seg_dir),
               name      = sub(".tif.*","",sub(".*tifs/","",imgs[i])))
 }
}

### classification
if(classify.test == TRUE) {
  tifs = dir(paste0(output_dir,"tifs/"),
             full.names=T,
             pattern=".tif$")
  shps = dir(paste0(output_dir,"shps/"),
             full.names=T,
             pattern=".shp$")
  output_shps = paste0(output_dir,"classified/")

  sfInit(parallel=TRUE, cpus=parallel::detectCores()-1)
  sfExport("tifs","shps","output_shps","classify_tiles","rfp","minx","maxx","meanx","sdx","zonal.stats.small")
  sfLibrary(rgdal)
  sfLibrary(raster)
  sfLibrary(randomForest)
  sfLibrary(spatialEco)
  sfLibrary(rgeos)
  sfLibrary(sp)
  
  out.lst = sfClusterApplyLB(1:length(tifs),
                           function(x){classify_tiles(x, tifs, shps, output_shps)})
  sfStop()

  cs = dir(output_shps, pattern=".shp$",full.names=T)
  
  mosaic_shps = function(u,cs){
    s = st_read(cs[u])
    diss = s %>%
      group_by(class) %>% 
      summarise() %>% 
      st_buffer(0)
  }

  cl=parallel::makeCluster(detectCores()-1)
  registerDoParallel(cl)

  m = foreach(u=1:length(cs),
              .combine=rbind,
              .packages=c("sf","tidyverse")) %dopar% {
                mosaic_shps(u, cs)}

  stopCluster(cl)
  plot(m)
  
  st_write(m,
         paste0(output_dir,"classified/",output_name),
         driver="GPKG",
         delete_dsn=T)
}

```


```{r}
library(sf)
tiles = SpatialPolygonsDataFrame(tile.lst, data=data.frame(c(1:length(tile.lst@polygons))))
tt = spTransform(tiles, CRS("+init=epsg:4326"))

tt2 = st_transform(m, CRS("+init=epsg:4326"))

centers <- data.frame(gCentroid(tt, byid = TRUE))
centers$ID = row.names(tt)
library(leaflet)
leaflet() %>% 
  addTiles() %>% 
  addPolygons(data=tt2) %>% 
  addLabelOnlyMarkers(data=centers,
                      label=~ID,
                      lng=~x,
                      lat=~y,
                      labelOptions = labelOptions(noHide = TRUE,
                                                  direction = 'top',
                                                  textOnly = TRUE))


```

