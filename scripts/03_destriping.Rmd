---
title: "03_destriping"
author: "Arthur de GrandprÃ©"
date: "03 feb 2021"
output: 
  html_document: 
    toc: yes
    toc_float: yes
---
# Notes : to fix
 1. Is it adjusted to the mean or to the first stripe ? (probably the first stripe!)



# Intro
This is the third script of the Open HRRS W2 workflow for open source high resolution remote sensing of vegetation cover optically complex waters.  

Some images have important radiometric vertical artifacts generated by irregularities within the pushbroom sensor arrays. This scripts allows to correct them partially by identifying them manually and adjusting the scenes to towards a mean radiometric calibration.  
  
Doing so requires two manually created inputs (can be done in QGIS or ArcGIS) : 
- A shapefile representing the first stripe in the image, starting from the left  
- A shapefile of radiometrically similar objects from one side to the other of every stripe, where polygons on the left side are identified "1" and right side "2"

# 1. Setting up the R environment

# 1.1. Libraries

First, load the required libraries. They can be installed using the *install.packages("package.name")* function.

```{r setup, warning=F, message=F}
rm(list=ls()) ; gc()

# install.packages("exactextractr") # must be installed
library(tidyverse)
library(sp)
library(sf)
library(raster)
library(rgdal)
library(spatialEco)
```

## 1.2. Inputs and Outputs

Second, define our inputs and outputs, listing the images that require destriping and the path to the shapefiles created in qgis.

```{r paths, eval=T}

boa_input = dir("../data/work/boa_output/", pattern=".tif$", full.names = T) # path of BOA reflectance output

destripe_output = "../data/work/destripe_output/"

MUL_input = boa_input[str_detect(boa_input,"PAN",negate=TRUE)]
to_correct = MUL_input[c(1)] # select images that must be corrected


stripe_path = dir("../data/subset/destriping/", pattern="stripe.gpkg$", full.names=T)
stripe_path = stripe_path[1]


plot(st_read(stripe_path[1])) # for visualisation
overlap_path = dir("../data/subset/destriping/", pattern="overlap.gpkg$", full.names=T)
overlap_path = overlap_path[1]
plot(st_read(overlap_path[1])) # for visualisation


# ignore (old)
# images_to_destripe = c("2009","2013_40_P001","2013_50_P001","2016_20_P002","2016_30_P001","2016_30_P002","2017","2018_10_P001","2018_10_P002","2019_P001","2019_P002")
# to_Correct = MUL_input[str_detect(MUL_input, paste(paste0("/",years_to_destripe), collapse = "|"))]
```

## 1.3. Define functions

There are no functions to define prior to running this script.  
  
# 2. Destriping correction

The correction extracts zonal statistics from polygons in one stripe and compares them to the polygons from the next. Since they should represent spectraly similar objects, the offset between both stripes is substracted to make them spectrally equal. The correction then moves to the next stripe, comparing it with the next, until the last one.

```{r, eval=F}

if(dir.exists(destripe_output)){}else{
  dir.create(destripe_output)
  }

file.copy(from = boa_input,
          to = destripe_output,
          recursive = F,
          overwrite = F,
          copy.mode = T) # so all files are still within the same folder, even if they are not all corrected.

imgs = to_correct

for(i in 1:length(imgs)){
  # i=1 #for testing
  
  r = brick(imgs[i])
  
  if(proj4string(r)!= "+proj=utm +zone=18 +datum=WGS84 +units=m +no_defs"){
    r = projectRaster(r, crs="+init=epsg:32618")
  }
  
  # load polygon of first stripe
  stripe = st_read(stripe_path[i]) %>% 
    st_transform(crs(r))
  
  # calculate distance between stripes based on horizontal distance between vertexes
  coords_stripe = st_coordinates(stripe)
  if(max(coords_stripe[,1])==sort(coords_stripe[,1])[length(coords_stripe[,1])-1]){
    offset = sort(coords_stripe[,1])[length(coords_stripe[,1])-2]-min(st_coordinates(stripe)[,1])
    } else{
    offset = sort(coords_stripe[,1])[length(coords_stripe[,1])-1]-min(st_coordinates(stripe)[,1])
    }
  
  # load overlapping objects polygon
  overlap = st_read(overlap_path[i]) %>% 
    st_transform(crs(r))
  
  # calculate number of stripes
  n_stripes = ceiling(ncol(r)*res(r)[1]/offset)

  # correct stripe by stripe
  r2 = r

  # n_stripes=3 #used for testing
  # k=3
  for(k in 1:(n_stripes-1)){
  # k=1
    print(paste0("image ",i," of ",length(imgs)," for stripe ",k," out of ",n_stripes))
    
    # clip first image stripe
    stripe1 = stripe
    stripe1 = stripe1 %>% st_cast("POLYGON")
    stripe1 = st_sf(st_geometry(stripe1)+c((k-1)*offset,0),crs=26918)
    rs = mask(r2, stripe1)
    
    # zonal stats in long format
    overlap1 = subset(overlap, overlap$id==1)
    zs = zonal.stats(as_Spatial(overlap1), rs, stats="mean")
    if(length(names(r))==8){
      colnames(zs) = c("C","B","G","Y","R","RE","N","N2")} else{
        colnames(zs) = c("B","G","R","N")}
    zs$poly = seq(1:length(zs[,1]))
    if(ncol(zs)>5){zs1 = pivot_longer(zs,1:8)} else{
      zs1 = pivot_longer(zs,1:4)
    }
    
  
    if(k==1){
      stripe2 = stripe
      zs2 = zonal.stats(as_Spatial(overlap), r2, stats="mean")
       if(length(names(r))==8){
      colnames(zs2) = c("C","B","G","Y","R","RE","N","N2")} else{
        colnames(zs2) = c("B","G","R","N")}
    zs2$poly = seq(1:length(zs2[,1])) 
     if(ncol(zs2)>5){zs2 = pivot_longer(zs2,1:8)} else{
      zs2 = pivot_longer(zs2,1:4)
    }
    
    # calculate offset table
    colnames(zs2) = c("poly","name","value2")
    zs1 = merge(zs1,zs2,all=T)
    # zs1$value2=zs2$value
    
    agg_table = aggregate(zs1[,3:4], list(zs1$name), mean, na.rm=T)
    agg_table$offset = agg_table$value-agg_table$value2
    agg_table = agg_table %>% arrange(factor(Group.1, levels = c("C","B","G","Y","R","RE","N","N2")))
    
    # apply offset correction 
    rs2f = rs - agg_table$offset
    r2 = cover(rs2f,r2)
    
    rs = mask(r2, stripe1)
    
    # zonal stats in long format
    zs = zonal.stats(as_Spatial(overlap1), rs, stats="mean")
    if(length(names(r))==8){
      colnames(zs) = c("C","B","G","Y","R","RE","N","N2")} else{
        colnames(zs) = c("B","G","R","N")}
    zs$poly = seq(1:length(zs[,1]))
    if(ncol(zs)>5){zs1 = pivot_longer(zs,1:8)} else{
      zs1 = pivot_longer(zs,1:4)
    }
    }
    
    ## compare with next stripe
    # clip next stripe
    
    stripe2 = stripe
    stripe2 = stripe2 %>% st_cast("POLYGON")
    stripe2 = st_sf(st_geometry(stripe2)+c(k*offset,0),crs=26918)
    rs2 = mask(r2, stripe2)
    
    # zonal stats of second stripe
    overlap2 = subset(overlap, overlap$id==2)
    zs2 = zonal.stats(as_Spatial(overlap2), rs2, stats="mean")
    if(length(names(r))==8){
      colnames(zs2) = c("C","B","G","Y","R","RE","N","N2")} else{
        colnames(zs2) = c("B","G","R","N")}
    zs2$poly = seq(1:length(zs2[,1])) 
     if(ncol(zs2)>5){zs2 = pivot_longer(zs2,1:8)} else{
      zs2 = pivot_longer(zs2,1:4)
    }
    
    # calculate offset table
    colnames(zs2) = c("poly","name","value2")
    zs1 = merge(zs1,zs2,all=T)
    # zs1$value2=zs2$value
    
    agg_table = aggregate(zs1[,3:4], list(zs1$name), mean, na.rm=T)
    agg_table$offset = agg_table$value-agg_table$value2
    agg_table = agg_table %>% arrange(factor(Group.1, levels = c("C","B","G","Y","R","RE","N","N2")))
    
    # apply offset correction 
    rs2f = rs2 + agg_table$offset
    r2 = cover(rs2f,r2)
  }
writeRaster(r2, paste0(destripe_output,gsub(".*boa_output/","",imgs[i])), overwrite=T)
}
# plot(r2[[8]])
```
